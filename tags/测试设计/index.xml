<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>测试设计 on 软件测试同学</title>
    <link>https://naod.com.cn/tags/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1/</link>
    <description>Recent content in 测试设计 on 软件测试同学</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Copyright 2022 www.naod.com.cn</copyright>
    <lastBuildDate>Fri, 20 Mar 2020 09:55:17 +0000</lastBuildDate><atom:link href="https://naod.com.cn/tags/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>测试人员复现BUG的一些思路</title>
      <link>https://naod.com.cn/2020/03/%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%A4%8D%E7%8E%B0bug%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Fri, 20 Mar 2020 09:55:17 +0000</pubDate>
      
      <guid>https://naod.com.cn/2020/03/%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%A4%8D%E7%8E%B0bug%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/</guid>
      <description>对于测试人员，被开发人员要求复现BUG是家常便饭。特别针对在测试过程中低概率出现的BUG，会让我们觉得难以着手。下面我就谈一谈我的一些思路吧。 我认为一个BUG是由三个要素构成的：环境、数据、操作步骤。那么如何从这三点入手，总结了以下思路：
1.BUG本地“再现” （1）确定问题发生的环境，比如哪个浏览器的哪个版本发生的此现象。 （2）使用导致问题出现的数据。 （3）按照之前的操作步骤进行操作，使BUG再次出现
2.分析本地复现BUG需要的环境、数据、步骤，找出根本原因 （1）查看其他浏览器在相同数据，同样操作步骤的情况下是否仍旧会使该BUG出现。明确是否是特定浏览器，还是在其他浏览器都会出现。
（2）是否是数据的特殊性造成的问题？是单个数据？还是相似的一类数据？还是所有的数据？
（3）剖析操作步骤，尽量找到最短路径。
a.分解操作步骤
b.分析每一步骤的前提条件、期望结果。找到导致BUG产生的可能的必要操作步骤。如果期望结果与实际结果不同，猜测造成的原因，这时，可以通过抓包等一些工具来帮助分析其中的原因。
c.思考产生问题的可能原因和相关的操作步骤，明确一下产生的步骤，进行尝试，验证自己的想法是否正确。
3.如何在其他环境复现BUG 为了进一步明确问题的普遍性，确定自己环境的没有特殊的设置，需要在其他电脑上按照总结出来的产生bug的三要素，来重现BUG。对于通过上述步骤没有出现BUG的机器，要进一步追踪原因，查看为什么没有发生问题。 个人经验、之前分析步骤时的一些猜测。对于web端来说，一般可以从浏览器的配置，设置等出发。比较两个环境的不同。
4.分析、寻找BUG的最短路径 结合2.3两步的结论，同时结合自己的分析和判断寻找到最短路径。找到产生问题的根本原因。当然，如果因为技术限制，可以找其他人员一起查看原因，最终一定要定位到产生问题的根本原因。并要总结和记录。</description>
    </item>
    
    <item>
      <title>测试建模：Google ACC</title>
      <link>https://naod.com.cn/2020/03/%E6%B5%8B%E8%AF%95%E5%BB%BA%E6%A8%A1google-acc/</link>
      <pubDate>Fri, 06 Mar 2020 14:00:50 +0000</pubDate>
      
      <guid>https://naod.com.cn/2020/03/%E6%B5%8B%E8%AF%95%E5%BB%BA%E6%A8%A1google-acc/</guid>
      <description>ACC（Attributes Components Capability）是Google测试团队使用的一种建模方法，用来快速地建立产品的模型，以指导下一步的测试计划和设计。 在Google内部，ACC得到较普遍的应用，一些工程师还开发了支持ACC模型的Web应用，并将其开源。本文将介绍ACC的内容，所引用的Google+的例子摘录自《How Google Tests Software》一书。此外，本文还将使用启发式测试策略模型（Heuristic Test Strategy Model，简称HTSM）来分析ACC。
运用ACC建模的第一步是确定产品的Attributes（属性）。 按照谷歌的定义，Attributes是产品的形容词（adjectives），是与竞争对手相区别的关键特征。按照敏捷开发的观点，Attributes是产品所交付的核心价值（values）。从HTSM的角度，Attributes位于HTSM-&amp;gt;Quality Criteria-&amp;gt;Operation Criteria，隶属于面向用户的质量标准。
Google+的Attributes如下：
○ Social（社交）：鼓励用户去分享信息和他们的状态 ○ Expressive（表现力）：用户可以运用各种功能去表达自我 ○ Easy（容易）：让用户以直观的方式做他们想做的事 ○ Relevant（相关）：只显示用户感兴趣的内容 ○ Extensible（可扩展）：能够与Google的已有功能、第三方网站和应用（Application）集成 ○ Private（隐私）：用户数据不会泄漏 ACC以Attribute开始，是产品竞争的自然选择，也符合Google的开发实践。
在Google的项目中，开发人员和测试人员的比例通常是10：1或更高。开发人员会编写大量的自动化测试用例，对产品实施周密的测试，因此测试人员主要关注用户价值和系统级测试。即便如此，测试人员也没有足够的资源测试所有用户行为。所以，测试人员需要通过确定Attributes来明确产品的核心价值，从而区分出测试对象的轻重缓急（priorities）。
获取Attributes的信息源可以是产品经理、市场营销人员、技术布道者、商业宣传材料、产品广告等。测试人员也可以使用“卖点漫游”（The Money Tour）来发掘和检验产品的卖点。
第二步是确定产品的Components（部件）。 Components是产品的名词（nouns），可以理解为产品的主要模块、组件、子系统。
从HTSM的角度，Components位于HTSM-&amp;gt;Product Elements-&amp;gt;Structure和HTSM-&amp;gt;Product Elements-&amp;gt;Function，即同时具备代码结构和产品功能的特征。
Google+的Components如下：
○ Profile（个人资料）：用户的帐户信息和兴趣爱好 ○ People（人脉）：用户已经连接的好友 ○ Stream（信息流）：由帖子、评论、通知、照片等组成的有序的信息流 ○ Circles（圈子）：将好友分组，如把不同的好友归于“朋友”、“同事”等小组 ○ Notifications（通知）：当用户被帖子提到时，向他显示提示信息 ○ Hangouts（视频群聊）：视频对话的小组 ○ Posts（帖子）：用户和好友所发表的信息 ○ Comments（评论）：对帖子、照片、视频等的评论 ○ Photos（照片）：用户和好友所上传的照片 Components可以看作功能列表（Function List）的顶层元素，是产品核心功能的清单。
《How Google Tests Software》建议Components列表要尽可能简单，10个Components很好，20个就太多了。其目的是重点考虑对产品、对用户最重要的功能与代码，并避免漫长的Components列表所导致的分析瘫痪。
第三步是确定产品的Capabilities（能力）。 Capabilities是产品的动词（verbs），描述了一个Component提供了何种能力来实现一个Attribute。
在HTSM的角度，Capabilities位于HTSM-&amp;gt;Product Elements-&amp;gt;Function和HTSM-&amp;gt;Quality Criteria-&amp;gt;Operation Criteria-&amp;gt;Capability，刻画了产品实现其核心价值的手段。
Capabilities通常是面向用户的（user-oriented），反映了用户视角的产品行为。测试人员也应该保持Capabilities矩阵的简洁，他们应该关注对用户而言最有价值、最有吸引力的能力，并在合适的抽象层次（right level of abstraction）记录Capabilities。</description>
    </item>
    
    <item>
      <title>不闹而语-测试用例设计方法-错误猜测法</title>
      <link>https://naod.com.cn/2018/05/%E4%B8%8D%E9%97%B9%E8%80%8C%E8%AF%AD-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E9%94%99%E8%AF%AF%E7%8C%9C%E6%B5%8B%E6%B3%95/</link>
      <pubDate>Mon, 21 May 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/05/%E4%B8%8D%E9%97%B9%E8%80%8C%E8%AF%AD-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E9%94%99%E8%AF%AF%E7%8C%9C%E6%B5%8B%E6%B3%95/</guid>
      <description>错误猜测是一种技术，鼓励经验丰富的测试人员考虑软件可能无法应对的情况。有些人似乎天生擅长测试而其他人都是优秀的测试人员，因为他们作为测试人员或使用特定系统有很多经验，因此能够发现其缺点。
这就是为什么在一定程度上应用更正式的技术之后使用的错误猜测方法可能非常有效。它还节省了大量时间，因为经验丰富的测试人员做出了假设和猜测，以找出原本无法找到的缺陷。
错误猜测的成功在很大程度上取决于测试人员的技能，因为优秀的测试人员知道缺陷最有可能存在的位置。什么是错误猜测 这就是为什么在一定程度上应用更正式的技术之后使用的错误猜测方法可能非常有效。在使用更正式的技术时，测试人员可能会更好地了解系统，它的作用以及它的工作原理。通过这种更好的理解，他或她可能更好地猜测系统可能无法正常工作的方式。
要尝试的典型条件包括除以零，空白（或无）输入，空文件和错误类型的数据（例如，需要数字的字母字符）。如果有人曾经说过一个系统或它所运行的环境“这种情况永远不会发生”，那么测试这种情况可能是一个好主意，因为关于在现场环境中将会发生什么和不会发生什么的这种假设往往是失败的原因。
错误猜测技术的结构化方法是列出可能的缺陷或故障，并设计试图产生它们的测试。这些缺陷和故障列表可以根据测试人员自己或其他人的经验，可用的缺陷和故障数据以及软件失效原因的常识来构建。</description>
    </item>
    
    <item>
      <title>测试用例设计方法-场景图法</title>
      <link>https://naod.com.cn/2018/04/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%9C%BA%E6%99%AF%E5%9B%BE%E6%B3%95/</link>
      <pubDate>Thu, 12 Apr 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/04/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%9C%BA%E6%99%AF%E5%9B%BE%E6%B3%95/</guid>
      <description>定义 现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。
应用 基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）；也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入到某个流（如备选流2和4）。</description>
    </item>
    
    <item>
      <title>测试用例设计方法-基于经验的测试</title>
      <link>https://naod.com.cn/2018/04/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%9F%BA%E4%BA%8E%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 12 Apr 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/04/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%9F%BA%E4%BA%8E%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%B5%8B%E8%AF%95/</guid>
      <description>在基于经验的技术中，人们的知识，技能和背景对测试条件和测试用例至关重要。
需要技术人员和业务人员的经验，因为他们为测试分析和设计过程带来了不同的观点。由于之前对类似系统的经验，他们可能有一个可能出错的想法，这对测试非常有用。什么是基于经验的测试 基于经验的技术与基于规范和基于结构的技术相结合，并且在没有规范或者规范不充分或过时时也使用。 这可能是用于低风险系统的唯一技术类型，但这种方法在极端时间压力下可能特别有用 - 实际上这是导致探索性测试的因素之一。</description>
    </item>
    
    <item>
      <title>测试用例设计方法-边界值分析</title>
      <link>https://naod.com.cn/2018/04/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 12 Apr 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/04/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90/</guid>
      <description>边界值分析（BVA）基于在分区之间的边界处进行测试。这里我们有两个有效边界（在有效分区中）和无效边界（在无效分区中）。
例如，考虑一台打印机，它具有从1到99的副本数量的输入选项。要应用边界值分析，我们将从有效分区中获取最小和最大（边界）值（1和在这种情况下，99分别与在有效分区（在这种情况下为0和100）相邻的每个无效分区中的第一个或最后一个值一起。在这个例子中，我们将有三个等价分区测试（三个分区中的每一个）和四个边界值测试。考虑上一节中描述的等价划分中的银行系统。 什么是边界值分析BVA因为边界值被定义为分区边缘上的那些值，所以我们确定了以下边界值： - $ 0.01（无效边界值，因为它位于无效分区的边缘），$ 0.00，$ 100.00，$ 100.01，$ 999.99和$ 1000.00，所有有效的边界值。因此，通过应用边界值分析，我们将对边界值进行六次测试。
比较我们天真的测试员Robbin所做的事情：他确实达到了一个边界值（100美元），尽管它比设计更偶然。因此，除了仅测试一半分区外，Robbin仅测试了六分之一的边界（因此他在查找任何边界缺陷方面效率较低）。
如果我们考虑所有我们对等效划分和边界值分析的测试，这些技术总共给我们9次测试，而罗比的测试只有16次，所以我们仍然效率更高，效率也高出三倍以上（测试四个分区和六个边界，因此总共10个条件与三个相比）。
通过显示表中的值，我们可以看到没有为7％的利率指定最大值。我们现在想知道帐户余额的最大值是什么，以便我们可以测试该边界。这被称为“开放边界”，因为分区的一侧保持打开，即未定义。但这并不意味着我们可以忽略它，我们仍应该尝试测试它，但问题是如何？
开放边界很难测试，但有不同的方法来处理它们。实际上，问题的最佳解决方案是找出应该指定的边界！一种方法是返回到规范，以查看是否已在其他地方为余额金额说明了最大值。如果是这样，那么我们知道我们的边界值是什么。另一种方法可能是调查系统的其他相关领域。
例如，持有账户余额数字的字段可能只有六位数加上两位小数。这将使最大账户余额为9999999.99美元，因此我们可以将其作为我们的最大边界值。如果我们仍然无法找到关于这个边界应该是什么的任何东西，那么我们可能需要使用直观或基于经验的方法通过输入试图使其失败的各种大值来检查它。
我们可以考虑边界值分析的另一个例子，我们可以将它应用于整个字符串（例如名称或地址）。字符串中的字符数是一个分区，例如，1到30个字符之间是有效边界为1和30的有效分区。无效边界将是0个字符（null，只需按Return键）和31个字符。这两个都应该产生错误消息。</description>
    </item>
    
    <item>
      <title>测试用例设计方法-因果图法</title>
      <link>https://naod.com.cn/2018/03/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95/</link>
      <pubDate>Sun, 11 Mar 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/03/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95/</guid>
      <description>定义 因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。
应用 等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。
如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。
1. 因果图介绍 1) 4种符号分别表示了规格说明中向4种因果关系。 2) 因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（或称原因），右结点表示输出状态（或称结果）。 3) C1表示原因，通常置于图的左部；e1表示结果，通常在图的右部。C1和e1均可取值0或1，0表示某状态不出现，1表示某状态出现。 2.因果图涉及的概念 1) 关系 Ø 恒等：若c1是1，则e1也是1；否则e1为0。
Ø 非：若c1是1，则e1是0；否则e1是1。
Ø 或：若c1或c2或c3是1，则e1是1；否则e1为0。“或”可有任意个输入。
Ø 与：若c1和c2都是1，则e1为1；否则e1为0。“与”也可有任意个输入。
2) 约束 输入状态相互之间还可能存在某些依赖关系，称为约束。例如,某些输入条件本身不可能同时出现。输出状态之间也往往存在约束。在因果图中,用特定的符号标明这些约束。
Ø 输入条件的约束有以下4类：
· E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。
· I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。
· O约束（唯一）；a和b必须有一个，且仅有1个为1。
· R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。
Ø 输出条件约束类型 输出条件的约束只有M约束（强制）：若结果a是1，则结果b强制为0。
3.采用因果图法设计测试用例的步骤： 分析软件规格说明描述中,那些是原因(即输入条件或输入条件的等价类),那些是结果(即输出条件),并给每个原因和结果赋予一个标识符。 分析软件规格说明描述中的语义，找出原因与结果之间,原因与原因之间对应的关系，根据这些关系,画出因果图。 由于语法或环境限制,有些原因与原因之间,原因与结果之间的组合情况不可能出现，为表明这些特殊情况,在因果图上用一些记号表明约束或限制条件。 把因果图转换为判定表。 把判定表的每一列拿出来作为依据,设计测试用例。 </description>
    </item>
    
    <item>
      <title>测试用例设计方法-功能图法</title>
      <link>https://naod.com.cn/2018/02/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%8A%9F%E8%83%BD%E5%9B%BE%E6%B3%95/</link>
      <pubDate>Thu, 01 Feb 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/02/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%8A%9F%E8%83%BD%E5%9B%BE%E6%B3%95/</guid>
      <description>定义 功能图由状态迁移图和布尔函数组成.状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间）,而迁移则指明状态的改变.同时要依靠判定表或因果图表示的逻辑功能.例,一个简化的自动出纳机ATM的功能图。
应用 1. 功能图介绍 一个程序的功能说明通常由动态说明和静态说明组成.动态说明描述了输入数据的次序或转移的次序.
静态说明描述了输入条件与输出条件之间的对应关系.对于较复杂的程序,由于存在大量的组合情况,因此,仅用静态说明组成的规格说明对于测试来说往往是不够的.必须用动态说明来补充功能说明.功能图方法是用功能图FD形式化地表示程序的功能说明,并机械地生成功能图的测试用例.
功能图模型由状态迁移图和逻辑功能模型构成.状态迁移图用于表示输入数据序列以及相应的输出数据.在状态迁移图中,由输入数据和当前状态决定输出数据和后续状态.逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系.逻辑功能模型只适合于描述静态说明,输出数据仅由输入数据决定.测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成.功能图方法其实是是一种黑盒白盒混合用例设计方法。
（功能图方法中,要用到逻辑覆盖和路径测试的概念和方法,其属白盒测试方法中 的内容.逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法.该方法要求测试人员对程序的逻辑结构有清楚的了解.由于覆盖测试的目标不同,逻辑覆盖可分为:语句覆盖,判定覆盖,判定-条件覆盖,条件组合覆盖及路径覆盖.下面我们指的逻辑覆盖和路径是功能或系统水平上的,以区别与白盒测试中的程序内部的.）
2. 测试用例生成方法 从功能图生成测试用例,得到的测试用例数是可接受的. 问题的关键的是如何从状态迁移图中选取测试用例. 若用节点代替状态,用弧线代替迁移,则状态迁移图就可转化成一个程序的控制流程图形式.问题就转化为程序的路径测试问题（如白盒测试）问题了.
3. 测试用例生成规则 为了把状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来,从功能图生成实用的测试用例,须定义下面的规则.在一个结构化的状态迁移（SST）中,定义三种形式的循环:顺序,选择和重复.但分辨一个状态迁移中的所有循环是有困难的.（其表示图形省略）。
4. 从功能图生成测试用例的过程 生成局部测试用例:在每个状态中,从因果图生成局部测试用例.局部测试用例由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成。 测试路径生成:利用上面的规则（三种）生成从初始状态到最后状态的测试路径。 测试用例合成:合成测试路径与功能图中每个状态中的局部测试用例.结果是初始状态到最后状态的一个状态序列,以及每个状态中输入数据与对应输出数据的组合。 5. 测试用例的合成算法 采用条件构造树.</description>
    </item>
    
    <item>
      <title>测试用例设计方法-决策表</title>
      <link>https://naod.com.cn/2018/01/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%86%B3%E7%AD%96%E8%A1%A8/</link>
      <pubDate>Thu, 04 Jan 2018 13:34:41 +0000</pubDate>
      
      <guid>https://naod.com.cn/2018/01/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95-%E5%86%B3%E7%AD%96%E8%A1%A8/</guid>
      <description>等价划分和边界值分析技术通常应用于特定情况或输入。但是，如果输入的不同组合导致采取不同的操作，则使用等效分区和边界值分析可能更难以显示，这往往更侧重于用户界面。
另外两种基于规范的软件测试技术，决策表和状态转换测试更侧重于业务逻辑或业务规则。
一个决策表的处理（例如输入）的东西组合的好方法。该技术有时也称为“因果”表。
tryqa 其原因在于存在一种称为“因果图形”的相关逻辑图表技术，它有时用于帮助推导决策表（迈尔斯将其描述为组合逻辑网络[Myers，1979]）。但是，大多数人发现使用[Copeland，2003]中描述的表更有用。
决策表提供了一种表明复杂业务规则的系统方法，这对开发人员和测试人员都很有用。 决策表可用于测试设计，无论它们是否在规范中使用，因为它们有助于测试人员探索必须正确实现业务规则的不同输入和其他软件状态组合的影响。 它有助于开发人员做得更好，也可以带来更好的关系。测试组合可能是一个挑战，因为组合的数量通常很大。如果不是不可能，测试所有组合可能是不切实际的。我们必须对仅测试一小部分组合感到满意，但是要选择要测试哪些组合以及哪些组合要省略也很重要。如果您没有系统的方法来选择组合，则将使用任意子集，这可能导致无效的测试工作。 如何使用决策表进行测试设计？ 第一项任务是确定一个合适的功能或子系统，它根据输入或事件的组合作出反应。系统不应包含太多输入，否则组合的数量将变得难以管理。
最好通过将它们分成子集并一次处理一个子集来处理大量条件。
一旦确定了需要组合的方面，然后将它们放入一个表中，列出了每个方面的所有True和False组合。
让我们考虑贷款申请的一个例子，您可以在其中输入每月还款金额或您想要支付的年数（贷款期限）。
如果同时输入两者，系统将在两者冲突时进行折衷。这两个条件是贷款金额和期限，因此我们将它们放在一个表格中（见表4.2）。
表4.2空决策表：
接下来，我们将确定True和False的所有组合（参见表4.3）。有两个条件，每个条件可以是真或假，我们将有四个组合（两个组合的事物数量的功率）。
请注意，如果我们有三个要结合的东西，我们将有八个组合，有四个东西，有16个，等等。
这就是为什么一次处理小组合很好的原因。为了跟踪我们有哪些组合，我们将在底行交替使用True和False，在底行上方的行上放置两个Trues然后两个Falses，等等，
所以最上面的行将包含所有的Trues，然后是所有的Falses（这个原则适用于所有这些表）。
表4.3带有输入组合的决策表： 在下一步中，我们现在将确定每种组合的正确结果（见表4.4）。在此示例中，我们可以输入两个字段中的一个或两个。每种组合有时被称为规则。
表4.4包含组合和结果的决策表： 在这一点上，我们可能会意识到，如果客户没有在两个字段中的任何一个字段中输入任何内容，我们就没有想过会发生什么。
该表突出显示了此示例的规范中未提及的组合。我们可以假设这种组合应该导致错误消息，因此我们需要添加另一个操作（参见表4.5）。
这凸显了该技术的优势，可以发现规范中的遗漏和含糊之处。某些组合从规范中省略是很常见的; 因此，在审查测试基础时，这也是一种有价值的技术。
表4。5具有附加结果的决策表： 现在，我们在此示例中稍作更改，以便不允许客户同时输入还款和期限。现在我们表的结果将会改变，因为如果输入两者，也应该有一条错误消息，所以它看起来像表4.6。
表4。6变更结果的决策表： 您现在可能会注意到每列中只有一个“是”，即我们的操作是互斥的 - 每个条件组合只会发生一个操作。
我们可以通过列出一行单元格中的操作以不同的方式表示这一点，如表4.7所示。请注意，如果任何组合产生多个操作，那么最好将它们显示为单独的行，而不是将它们组合成一行。
表4.7一行结果的决策表： 这种技术的最后一步是编写测试用例来练习表中的四个规则。
信用卡示例： 让我们再举一个例子。如果您是新客户，并且想要开设信用卡账户，那么有三个条件，首先您将获得今天所有购买的15％折扣，第二个如果您是现有客户并且持有会员卡，则获得10％的折扣和第三，如果你有优惠券，你今天可以获得20％的折扣（但它不能与&amp;rsquo;新客户&amp;rsquo;折扣一起使用）。
如果适用，则添加折扣金额。如表4.8所示。
表4.8信用卡示例的决策表
在表4.8中，条件和操作列在左侧列中。决策表中的所有其他列均表示单独的规则，每个条件对应一个条件。
我们可能会选择测试每个规则/组合，如果只有少数，那么通常就是这种情况。但是，如果规则/组合的数量很大，我们更有可能通过选择一个富子集进行测试来对它们进行抽样。
现在让我们看看上面显示的信用卡决策表：
请注意，我们已将X作为两个列（规则1和2）的折扣 - 这意味着不应发生此组合。根据上述条件，您既不能成为新客户，也不能持有会员卡。因此，应该有一条错误消息说明这一点。 我们在规则3中做出了假设。由于优惠券的折扣大于新客户折扣，我们假设客户将选择20％而不是15％。我们无法添加它们，因为优惠券不能与上述条件中所述的“新客户”折扣一起使用。20％的行动是我们的假设，我们应该通过询问编写规范的人或用户来检查这个假设（以及我们做出的任何其他假设）是否正确。 但是，对于规则5，我们可以添加折扣; 因为优惠券和会员卡折扣都应该适用（这是我们的假设）。 规则4,6和7只有一种折扣，规则8没有折扣，所以0％。 如果我们彻底应用这种技术，我们将对决策表的每个列或规则进行一次测试。这样做的好处是，我们可能会测试一些我们可能没有测试过但可能发现缺陷的组合。
但是，如果我们有很多组合，那么测试每种组合可能是不可能或不明智的。如果我们有时间限制，我们可能没有时间测试所有组合。不要只是假设需要测试所有组合。
优先考虑和测试最重要的组合总是更好。拥有全表有助于我们决定哪些组合应该测试，哪些组合不要测试。
在上面的示例中，所有条件都是二进制的，即它们只有两个可能的值：True或False（或者我们可以说是或否）。</description>
    </item>
    
    <item>
      <title>如何去做需求评审和需求分析</title>
      <link>https://naod.com.cn/2016/08/%E5%A6%82%E4%BD%95%E5%8E%BB%E5%81%9A%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1%E5%92%8C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 28 Aug 2016 14:26:21 +0000</pubDate>
      
      <guid>https://naod.com.cn/2016/08/%E5%A6%82%E4%BD%95%E5%8E%BB%E5%81%9A%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1%E5%92%8C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</guid>
      <description>需求评审和需求分析是作为软件测试工程师工作中常见的工作内容 如何做好软件需求分析和需求评审，我常用的一些评审点如下：
设计方案正确性、先进性、可行性；
系统组成、系统要求及接口协调的合理性；
软件实现的功能是否覆盖了产品需求文档中要求的功能；
功能的实现中，是否考虑到了所有可能的分支情况，以及这些分支情况的处理是 否合理，和PD要求是否一致；
对于功能模块的输入参数、输出参数的定义是否明确；
系统性能、可靠性、安全性要求是否合理；
文档的描述是否清晰、明确。</description>
    </item>
    
  </channel>
</rss>
